// ----------------------------------------------------------------------------
// F# promise extensions (PromiseSeq.fs)
// (c) Tomas Petricek, 2011, Available under Apache 2.0 license.
// ----------------------------------------------------------------------------
namespace Fable.PowerPack

open System
open Fable.Import

/// Module with helper functions for working with asynchronous sequences
[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module PromiseSeq =

  /// Creates an empty asynchronou sequence that immediately ends
  [<GeneralizableValue>]
  let empty<'T> : PromiseSeq<'T> =
    Promise.lift Nil

  /// Creates an asynchronous sequence that generates a single element and then ends
  let singleton (v:'T) : PromiseSeq<'T> =
    Promise.lift (Cons(v, empty))

  /// Yields all elements of the first asynchronous sequence and then
  /// all elements of the second asynchronous sequence.
  let rec append (seq1: PromiseSeq<'T>) (seq2: PromiseSeq<'T>) : PromiseSeq<'T> =
    promise { let! v1 = seq1
            match v1 with
            | Nil -> return! seq2
            | Cons (h,t) -> return Cons(h,append t seq2) }


  /// Computation builder that allows creating of asynchronous
  /// sequences using the 'promiseSeq { ... }' syntax
  type PromiseSeqBuilder() =
    member x.Yield(v) = singleton v
    // This looks weird, but it is needed to allow:
    //
    //   while foo do
    //     do! something
    //
    // because F# translates body as Bind(something, fun () -> Return())
    member x.Return(()) = empty
    member x.YieldFrom(s) = s
    member x.Zero () = empty
    member x.Bind (inp:JS.Promise<'T>, body : 'T -> PromiseSeq<'U>) : PromiseSeq<'U> =
      promise.Bind(inp, body)
    member x.Combine (seq1:PromiseSeq<'T>,seq2:PromiseSeq<'T>) =
      append seq1 seq2
    member x.While (gd, seq:PromiseSeq<'T>) =
      if gd() then x.Combine(seq,x.Delay(fun () -> x.While (gd, seq))) else x.Zero()
    member x.Delay (f:unit -> PromiseSeq<'T>) =
      promise.Delay(f)


  /// Builds an asynchronou sequence using the computation builder syntax
  let promiseSeq = new PromiseSeqBuilder()

  /// Tries to get the next element of an asynchronous sequence
  /// and returns either the value or an exception
  let internal tryNext (input:PromiseSeq<_>) = promise {
    try
      let! v = input
      return Choice1Of2 v
    with e ->
      return Choice2Of2 e }

  /// Implements the 'TryWith' functionality for computation builder
  let rec internal tryWith (input : PromiseSeq<'T>) handler =  promiseSeq {
    let! v = tryNext input
    match v with
    | Choice1Of2 Nil -> ()
    | Choice1Of2 (Cons (h, t)) ->
        yield h
        yield! tryWith t handler
    | Choice2Of2 rest ->
        yield! handler rest }

  /// Implements the 'TryFinally' functionality for computation builder
  let rec internal tryFinally (input : PromiseSeq<'T>) compensation = promiseSeq {
    let! v = tryNext input
    match v with
    | Choice1Of2 Nil ->
        compensation()
    | Choice1Of2 (Cons (h, t)) ->
        yield h
        yield! tryFinally t compensation
    | Choice2Of2 e ->
        compensation()
        yield! raise e }

  /// Creates an asynchronou sequence that iterates over the given input sequence.
  /// For every input element, it calls the the specified function and iterates
  /// over all elements generated by that asynchronous sequence.
  /// This is the 'bind' operation of the computation expression (exposed using
  /// the 'for' keyword in promiseSeq computation).
  let rec collect f (input : PromiseSeq<'T>) : PromiseSeq<'TResult> = promiseSeq {
    let! v = input
    match v with
    | Nil -> ()
    | Cons(h, t) ->
        yield! f h
        yield! collect f t }


  // Add additional methods to the 'promiseSeq' computation builder
  type PromiseSeqBuilder with
    member x.TryFinally (body: PromiseSeq<'T>, compensation) =
      tryFinally body compensation
    member x.TryWith (body: PromiseSeq<_>, handler: (exn -> PromiseSeq<_>)) =
      tryWith body handler
    member x.Using (resource:#IDisposable, binder) =
      tryFinally (binder resource) (fun () ->
        if box resource <> null then resource.Dispose())

    /// For loop that iterates over a synchronous sequence (and generates
    /// all elements generated by the asynchronous body)
    member x.For(seq:seq<'T>, action:'T -> PromiseSeq<'TResult>) =
      let mutable cur = Unchecked.defaultof<_>
      let enum: JS.Iterator<'T> = unbox(seq.GetEnumerator())
      x.While(
        (fun () -> cur <- enum.next(); not cur.``done``),
        x.Delay(fun () -> action cur.value.Value))

    /// Asynchronous for loop - for all elements from the input sequence,
    /// generate all elements produced by the body (asynchronously). See
    /// also the PromiseSeq.collect function.
    member x.For (seq:PromiseSeq<'T>, action:'T -> PromiseSeq<'TResult>) =
      collect action seq


  // Add asynchronous for loop to the 'promise' computation builder
  type Promise.PromiseBuilder with
    member x.For (seq:PromiseSeq<'T>, action:'T -> JS.Promise<unit>) =
      promise.Bind(seq, function
        | Nil -> promise.Zero()
        | Cons(h, t) -> promise.Combine(action h, x.For(t, action)))

  // --------------------------------------------------------------------------
  // Additional combinators (implemented as promise/promiseSeq computations)

  /// Builds a new asynchronous sequence whose elements are generated by
  /// applying the specified function to all elements of the input sequence.
  ///
  /// The specified function is asynchronous (and the input sequence will
  /// be asked for the next element after the processing of an element completes).
  let mapAsync f (input : PromiseSeq<'T>) : PromiseSeq<'TResult> = promiseSeq {
    for itm in input do
      let! v = f itm
      yield v }

  /// Asynchronously iterates over the input sequence and generates 'x' for
  /// every input element for which the specified asynchronous function
  /// returned 'Some(x)'
  ///
  /// The specified function is asynchronous (and the input sequence will
  /// be asked for the next element after the processing of an element completes).
  let chooseAsync f (input : PromiseSeq<'T>) : PromiseSeq<'R> = promiseSeq {
    for itm in input do
      let! v = f itm
      match v with
      | Some v -> yield v
      | _ -> () }

  /// Builds a new asynchronous sequence whose elements are those from the
  /// input sequence for which the specified function returned true.
  ///
  /// The specified function is asynchronous (and the input sequence will
  /// be asked for the next element after the processing of an element completes).
  let filterAsync f (input : PromiseSeq<'T>) = promiseSeq {
    for v in input do
      let! b = f v
      if b then yield v }

  /// Asynchronously returns the last element that was generated by the
  /// given asynchronous sequence (or the specified default value).
  let rec lastOrDefault def (input : PromiseSeq<'T>) = promise {
    let! v = input
    match v with
    | Nil -> return def
    | Cons(h, t) -> return! lastOrDefault h t }

  /// Asynchronously returns the first element that was generated by the
  /// given asynchronous sequence (or the specified default value).
  let firstOrDefault def (input : PromiseSeq<'T>) = promise {
    let! v = input
    match v with
    | Nil -> return def
    | Cons(h, _) -> return h }

  /// Aggregates the elements of the input asynchronous sequence using the
  /// specified 'aggregation' function. The result is an asynchronous
  /// sequence of intermediate aggregation result.
  ///
  /// The aggregation function is asynchronous (and the input sequence will
  /// be asked for the next element after the processing of an element completes).
  let rec scanAsync f (state:'TState) (input : PromiseSeq<'T>) = promiseSeq {
    let! v = input
    match v with
    | Nil -> ()
    | Cons(h, t) ->
        let! v = f state h
        yield v
        yield! t |> scanAsync f v }

  /// Iterates over the input sequence and calls the specified function for
  /// every value (to perform some side-effect asynchronously).
  ///
  /// The specified function is asynchronous (and the input sequence will
  /// be asked for the next element after the processing of an element completes).
  let rec iterAsync f (input : PromiseSeq<'T>) = promise {
    for itm in input do
      do! f itm }

  /// Returns an asynchronous sequence that returns pairs containing an element
  /// from the input sequence and its predecessor. Empty sequence is returned for
  /// singleton input sequence.
  let rec pairwise (input : PromiseSeq<'T>) = promiseSeq {
    let! v = input
    match v with
    | Nil -> ()
    | Cons(h, t) ->
        let prev = ref h
        for v in t do
          yield (!prev, v)
          prev := v }

  /// Aggregates the elements of the input asynchronous sequence using the
  /// specified 'aggregation' function. The result is an asynchronous
  /// workflow that returns the final result.
  ///
  /// The aggregation function is asynchronous (and the input sequence will
  /// be asked for the next element after the processing of an element completes).
  let rec foldAsync f (state:'TState) (input : PromiseSeq<'T>) =
    input |> scanAsync f state |> lastOrDefault state

  /// Same as PromiseSeq.foldAsync, but the specified function is synchronous
  /// and returns the result of aggregation immediately.
  let rec fold f (state:'TState) (input : PromiseSeq<'T>) =
    foldAsync (fun st v -> f st v |> promise.Return) state input

  /// Same as PromiseSeq.scanAsync, but the specified function is synchronous
  /// and returns the result of aggregation immediately.
  let rec scan f (state:'TState) (input : PromiseSeq<'T>) =
    scanAsync (fun st v -> f st v |> promise.Return) state input

  /// Same as PromiseSeq.mapAsync, but the specified function is synchronous
  /// and returns the result of projection immediately.
  let map f (input : PromiseSeq<'T>) =
    mapAsync (f >> promise.Return) input

  /// Same as PromiseSeq.iterAsync, but the specified function is synchronous
  /// and performs the side-effect immediately.
  let iter f (input : PromiseSeq<'T>) =
    iterAsync (f >> promise.Return) input

  /// Same as PromiseSeq.chooseAsync, but the specified function is synchronous
  /// and processes the input element immediately.
  let choose f (input : PromiseSeq<'T>) =
    chooseAsync (f >> promise.Return) input

  /// Same as PromiseSeq.filterAsync, but the specified predicate is synchronous
  /// and processes the input element immediately.
  let filter f (input : PromiseSeq<'T>) =
    filterAsync (f >> promise.Return) input

  // /// Combines two asynchronous sequences into a sequence of pairs.
  // /// The values from sequences are retrieved in parallel.
  // let rec zip (input1 : PromiseSeq<'T1>) (input2 : PromiseSeq<'T2>) : PromiseSeq<_> = promise {
  //   let! ft = input1 |> JS.Promise.StartChild
  //   let! s = input2
  //   let! f = ft
  //   match f, s with
  //   | Cons(hf, tf), Cons(hs, ts) ->
  //       return Cons( (hf, hs), zip tf ts)
  //   | _ -> return Nil }

  /// Returns elements from an asynchronous sequence while the specified
  /// predicate holds. The predicate is evaluated asynchronously.
  let rec takeWhileAsync p (input : PromiseSeq<'T>) : PromiseSeq<_> = promise {
    let! v = input
    match v with
    | Cons(h, t) ->
        let! res = p h
        if res then
          return Cons(h, takeWhileAsync p t)
        else return Nil
    | Nil -> return Nil }

  /// Skips elements from an asynchronous sequence while the specified
  /// predicate holds and then returns the rest of the sequence. The
  /// predicate is evaluated asynchronously.
  let rec skipWhileAsync p (input : PromiseSeq<'T>) : PromiseSeq<_> = promise {
    let! v = input
    match v with
    | Cons(h, t) ->
        let! res = p h
        if res then return! skipWhileAsync p t
        else return! t
    | Nil -> return Nil }

  /// Returns elements from an asynchronous sequence while the specified
  /// predicate holds. The predicate is evaluated synchronously.
  let rec takeWhile p (input : PromiseSeq<'T>) =
    takeWhileAsync (p >> promise.Return) input

  /// Skips elements from an asynchronous sequence while the specified
  /// predicate holds and then returns the rest of the sequence. The
  /// predicate is evaluated asynchronously.
  let rec skipWhile p (input : PromiseSeq<'T>) =
    skipWhileAsync (p >> promise.Return) input

  /// Returns the first N elements of an asynchronous sequence
  let rec take count (input : PromiseSeq<'T>) : PromiseSeq<_> = promise {
    if count > 0 then
      let! v = input
      match v with
      | Cons(h, t) ->
          return Cons(h, take (count - 1) t)
      | Nil -> return Nil
    else return Nil }

  /// Skips the first N elements of an asynchronous sequence and
  /// then returns the rest of the sequence unmodified.
  let rec skip count (input : PromiseSeq<'T>) : PromiseSeq<_> = promise {
    if count > 0 then
      let! v = input
      match v with
      | Cons(h, t) ->
          return! skip (count - 1) t
      | Nil -> return Nil
    else return! input }
